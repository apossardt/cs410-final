/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProjectGUI;
import java.util.ArrayList;
import java.awt.Dialog;
import java.awt.event.KeyEvent;
import java.util.LinkedList;
import java.util.List;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSetMetaData;

/**
 *
 * @author Steve
 */

public class PassageForm extends javax.swing.JFrame implements SMSFormListener{

    /**
     * Creates new form PassageForm
     */
    public PassageForm(String participant) {
        initComponents();
        
        getPassageText();
        String initialPassage = "";
        for(int i = 0; i <= 10; i++)
        {
            initialPassage += Passage[i];
        }
        
        lastVisibleLine =0;
        txtPassage.setText(initialPassage);
        upCount = 0;
        downCount = 0;
        lineCount = 11;
        startTime = System.currentTimeMillis();
        arrowRecords = new LinkedList<String[]>();
        smsTime = 0;
        ParticipantNumber = participant;
        smsCondition = Integer.parseInt(ParticipantNumber.substring(0, 1));
        smsCounter=0;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtPassage = new javax.swing.JTextPane();
        btnFinish = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Passage");
        setMinimumSize(new java.awt.Dimension(1150, 650));
        setPreferredSize(new java.awt.Dimension(1150, 650));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        txtPassage.setFont(new java.awt.Font("Tahoma", 0, 30)); // NOI18N
        txtPassage.setText("*** TEMPORARY PREVIEW TEXT, NOT FULL PASSAGE ***\nWe all think we know what a \"personality\" is. It's all the characteristic ways a person behaves and thinks: \"Michael tends to be shy\"; \"Mindy likes to be very dramatic\"; \"Juan is always suspicious of others\"; \"Annette is very outgoing\"; \"Bruce seems to be very sensitive and gets upset very easily over minor things\"; \"Sean has the personality of an eggplant!\" We tend to type people as behaving one way in many different situations. For example, like Michael, many of us are shy with people we don't know, but we won't be shy around our friends. A truly shy person is shy even among people he or she has known for some time.");
        txtPassage.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(txtPassage);

        btnFinish.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnFinish.setText("Finish");
        btnFinish.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFinishActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(1063, Short.MAX_VALUE)
                .addComponent(btnFinish)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(146, 146, 146)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 796, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 578, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(btnFinish)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void getPassageText()
    {
        try
        {
            Class.forName("org.apache.derby.jdbc.ClientDriver").newInstance();
            //Get a connection
            conn = DriverManager.getConnection(dbURL); 
        }
        catch (Exception except)
        {
            except.printStackTrace();
        }
        
        try
        {
            stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            ResultSet results = stmt.executeQuery("select * from " + tableName);
            ResultSetMetaData rsmd = results.getMetaData();
            
            results.last();
            int rows = results.getRow();
            // Move to beginning
            results.beforeFirst();
            
            
            
            Passage = new String[rows];
            int counter=0;
            while(results.next())
            {
                Passage[counter]= results.getString(2);
                counter++;
            }
            results.close();
            stmt.close();
        }
        catch (SQLException sqlExcept)
        {
            sqlExcept.printStackTrace();
        }
    }
    
    public void addListener(PassageListener toAdd) {
        listeners.add(toAdd);
    }

    public void DisplaySMSEvent() {
        //PassageSMSEventArgs args = new PassageSMSEventArgs(this,this);
        for (PassageListener hl : listeners)
            hl.displaySMS();
    }
    public void PassageCompleteEvent()
    {
        PassageResultEventArgs args = new PassageResultEventArgs(this);
        for(PassageListener h1:listeners)
            h1.passageComplete(args);
    }
    
    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        try {
            // Do not allow the user to edit the text.
            txtPassage.setEditable(false);
            
            // My thoughts are that we'll set the button invisible until the final line of text is revealed.
            // On that event, set it to visible. We could also do the same thing with disabling/enabling.
            btnFinish.setVisible(true);
            btnFinish.setEnabled(false);
        }
        catch (Exception ex) {
            // Log exception?
        }
    }//GEN-LAST:event_formWindowOpened

    private void btnFinishActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFinishActionPerformed
     
        this.setVisible(false);
        
        this.PassageCompleteEvent();
    }//GEN-LAST:event_btnFinishActionPerformed
    
    @Override
    public void smsFormComplete(SMSFormResults results)
    {
   
        if(smsCondition == 3 || smsCondition == 4)
            smsTime = results.smsTime;
    }

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        int keycode = evt.getKeyCode();
        lineCount++;
        
        if(lineCount>= Passage.length)
        {
            //this.setVisible(false);
            
            btnFinish.setEnabled(true);
        }
        else
        {
            String[] results= new String[3];
            long currentTime;
            double timeSinceZero;
            double seconds;
            switch(keycode)
            {
                case KeyEvent.VK_UP:

                currentTime = System.currentTimeMillis();
                timeSinceZero = (currentTime - startTime)-smsTime;

                seconds = timeSinceZero / 1000.0;

                upCount++;

                results[0] = "up";
                results[1]= Integer.toString(lineCount);
                results[2]= Double.toString(seconds);
                break;

                case KeyEvent.VK_DOWN: 

                currentTime = System.currentTimeMillis();
                timeSinceZero = (currentTime - startTime)-smsTime;

                seconds = timeSinceZero / 1000.0;

                downCount++;

                results[0] = "down";
                results[1]= Integer.toString(lineCount);
                results[2]= Double.toString(seconds);

                if(smsCondition ==3)
                {
                    
                    if((lineCount % 2) == 0 && smsCounter <5)
                    {
                        smsCounter++;
                        lastVisibleLine = lineCount;
                        DisplaySMSEvent();
                        txtPassage.setText(Passage[lineCount]);
                    }
                    else
                    {
                        String psg = "";
                        for(int i = lastVisibleLine; i <= lineCount;i++)
                        {
                            psg += Passage[i];
                        }
                        txtPassage.setText(psg);
                    }
                }
                else if(smsCondition == 4)
                {
                    if((lineCount % 2) == 0 && smsCounter <5)
                    {
                        smsCounter++;
                        DisplaySMSEvent();
                    }

                    String psg = "";
                    for(int i = 0; i <= lineCount;i++)
                    {
                        psg += Passage[i];
                    }
                    txtPassage.setText(psg);
                    
                }
                else
                {
                    String psg = "";
                    for(int i = 0; i < lineCount;i++)
                    {
                        psg += Passage[i];
                    }
                    txtPassage.setText(psg);
                }
                break;
            }

            arrowRecords.add(results);

            txtPassage.getSelectionEnd();
        
        }

        
    }//GEN-LAST:event_formKeyPressed


private final ArrayList<PassageListener> listeners = new ArrayList<>();

    private long startTime,endTime,totalTime;
    private int upCount,downCount,lineCount, smsCondition,lastVisibleLine, smsCounter;
    private String ParticipantNumber;
    private double smsTime;
    private String[]Passage;
    private List<String[]> arrowRecords;
    
   private static String dbURL = "jdbc:derby://localhost:1527/sidresDB;create=true;user=sidresAdmin;password=1x!Software";
    private static String tableName = "PASSAGETEXT";
    // jdbc Connection
    private static Connection conn = null;
    private static Statement stmt = null;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFinish;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextPane txtPassage;
    // End of variables declaration//GEN-END:variables
}
